from threading import Thread

num = 0

class Adder(Thread):
    def __init__(self, name_):
        Thread.__init__(self, name=name_)

    def run(self):  # 自定义线程类时，要重写这个run方法，用以执行类实例的功能
        global num  # 声明全局变量
        for i in range(10000000):
            num = num + 1

th1 = Adder("Adder1")
th1.start()
th2 = Adder("Adder2")
th2.start()

th1.join()  # 主线程等待th1线程结束
th2.join()  # 同上原理

print("result:", num)



# 备注：多次计算结果都是 200000000， 为什么计算是正确的，本来这应该每次结果都不同的啊. 原书上说这个结果每次不同。

#################################################################################################
# 问：为什么会与在原书上每次都得到不同结果的例子不同？

# 答：
# 摘自：通义千问2025-1-8

# 你提到的代码在多次运行时都得到了 200000000 的结果，这可能让你感到疑惑，因为根据线程间的竞争条件（race condition），
    # 通常预期的结果是不确定的。然而，在这个特定的情况下，Python 的全局解释器锁（GIL, Global Interpreter Lock）实际上是在保护
    # 你的增量操作，使得结果看似正确。

# Python 的 GIL
    # Python 的 CPython 实现中有一个叫做 GIL 的机制。GIL 是一个互斥锁，它确保在任何时刻只有一个线程在执行 Python 字节码。
    # 这意味着即使你在多线程环境中，每个线程也必须轮流获取 GIL 才能执行代码。对于 I/O 操作或长时间运行的外部计算，
    # 线程可以释放 GIL 以允许其他线程执行，但对于纯粹的 Python 代码（如算术运算），GIL 会限制同一时间只有一个线程在执行。

# 为什么结果看起来正确？
    # 在你的例子中，num += 1 这个操作虽然从理论上讲是一个读取-修改-写入的复合操作，但在 Python 中，这种简单的增量操作通常会被视为原子
    # 操作，特别是在 GIL 的作用下。由于 GIL 的存在，两个线程不会同时执行 num += 1，而是轮流执行，因此避免了直接的竞争条件。

# 为什么说“应该每次结果都不同”？
    # 在没有 GIL 的情况下，或者如果你使用的是真正的多线程环境（例如，使用多进程模块 multiprocessing 或者在没有 GIL 的 Python 解释器
    # 版本中），那么 num += 1 将不再被视为原子操作。
    # 这时，可能会发生以下情况：
        # 线程1 读取 num 的值。
        # 线程2 读取 num 的值。
        # 线程1 将 num 增加 1 并写回。
        # 线程2 将 num 增加 1 并写回。
    # 由于 线程2 在 线程1 写回之后再次写回，导致 线程1 的增加被覆盖，最终 num 只增加了 1 而不是 2。这就是所谓的竞争条件。


# 如何模拟竞争条件？
    # 如果你想模拟竞争条件并看到不确定的结果，可以尝试以下方法：
        # 增加操作复杂度：将 num += 1 替换为更复杂的操作，这样 GIL 更有可能在操作中间切换线程，从而引入竞争条件。例如：

# #---------------------------------------------------------------------
# temp = num
# temp += 1
# import time
# time.sleep(0)  # 强制让出 GIL
# num = temp
# #---------------------------------------------------------------------

# 使用 multiprocessing 模块：multiprocessing 模块创建的是真正的多进程，而不是线程。
    # 每个进程都有自己独立的 GIL，因此可以在多个核心上并行执行，从而更容易出现竞争条件。
# 使用无 GIL 的 Python 解释器：某些 Python 解释器（如 Jython 或 IronPython）不使用 GIL，
    # 因此在这些环境中，线程可以真正并发执行，更容易出现竞争条件。



# 如何正确处理共享资源？
    # 为了确保线程安全，你可以使用锁（Lock 或 RLock）来保护对共享资源的访问。例如：

# #---------------------------------------------------------------------
# from threading import Thread, Lock

# num = 0
# lock = Lock()

# class Adder(Thread):
#     def __init__(self, name_):
#         Thread.__init__(self, name=name_)

#     def run(self):
#         global num
#         for i in range(100000000):
#             with lock:  # 使用锁保护对 num 的访问
#                 num += 1

# th1 = Adder("Adder1")
# th2 = Adder("Adder2")
# th1.start()
# th2.start()

# th1.join()
# th2.join()

# print("result:", num)
# #---------------------------------------------------------------------
# 通过使用锁，你可以确保在同一时间只有一个线程能够访问和修改 num，从而避免竞争条件并保证结果的准确性。


# 总结
    # GIL 的存在：在 CPython 中，GIL 确保了在任何时刻只有一个线程在执行 Python 字节码，这使得简单的增量操作在这种环境下看起来
                # 是线程安全的。
    # 竞争条件：在没有 GIL 或更复杂的操作中，竞争条件会导致不确定的结果。你可以通过增加操作复杂度或使用多进程来模拟这种情况。
    # 线程安全：为了确保线程安全，建议使用锁或其他同步机制来保护对共享资源的访问。