摘自：通义千问 2024-12-25


装饰器（Decorator）的概念
    装饰器是 Python 中一种非常强大的工具，它允许你在不修改原始函数代码的情况下，动态地为函数添加新的功能。装饰器本质上是一个高阶函数，它接受一个函数作为参数，并返回一个新的函数或可调用对象。通过装饰器，你可以在函数执行前后添加额外的逻辑，或者修改函数的行为。



装饰器的核心思想：
    不修改原始函数的代码：装饰器不会改变原始函数的定义，而是通过包装的方式为其添加新功能。
    可复用性：装饰器可以应用于多个函数，因此它是实现代码复用的好方法。
    语法糖：Python 提供了 @decorator 语法糖，使得使用装饰器更加简洁和直观。


1. 装饰器的基本结构
    见例子


2. 带参数的装饰器
    有时，你可能希望装饰器能够接受参数，以便根据不同的参数来调整其行为。为了实现这一点，你可以创建一个“装饰器工厂”——即一个返回装饰器的函数。


3. 带有参数的被装饰函数
    如果被装饰的函数本身也接受参数，你需要确保装饰器能够正确处理这些参数。为此，可以在装饰器的 wrapper 函数中使用 *args 和 **kwargs 来接收任意数量的位置参数和关键字参数。



4. 类装饰器
    除了函数装饰器，Python 还支持 类装饰器。类装饰器可以用来装饰类，通常用于修改类的行为或添加类级别的功能。
    CountCalls 是一个类装饰器，它接受一个函数 func 作为参数，并将其存储在实例变量 self.func 中。
    __call__ 方法使类实例可以像函数一样被调用。每次调用 say_hello() 时，实际上是在调用 CountCalls 实例的 __call__ 方法。
    __call__ 方法会增加 num_calls 计数器，并打印调用次数，然后调用原始函数 say_hello。



5. 多层装饰器
    你可以为同一个函数应用多个装饰器。Python 会从最内层的装饰器开始向外层依次应用每个装饰器。


6. 保留元信息的装饰器
    默认情况下，装饰器会替换原始函数，导致一些元信息（如函数名、文档字符串等）丢失。为了避免这种情况，你可以使用 functools.wraps 装饰器来保留原始函数的元信息。


7. 内置装饰器
    Python 提供了一些内置的装饰器，常见的有：
    @staticmethod：将方法标记为静态方法，不需要传递 self 参数。
    @classmethod：将方法标记为类方法，第一个参数是类本身（通常是 cls），而不是实例。
    @property：将方法转换为属性，允许你通过点符号访问方法的结果，而不需要调用它。
    @functools.lru_cache：为函数添加缓存功能，避免重复计算相同的结果。


8. 装饰器的应用场景
    装饰器在许多编程场景中都非常有用，尤其是在以下情况下：
    日志记录：可以在函数执行前后记录日志，方便调试和监控。
    性能计时：可以为函数添加计时功能，测量函数的执行时间。
    权限验证：可以在函数执行前检查用户是否有权限执行该操作。
    缓存结果：可以为函数添加缓存功能，避免重复计算相同的结果。
    重试机制：可以在函数失败时自动重试，直到成功或达到最大重试次数。


9. 总结
    装饰器 是 Python 中一种强大的工具，允许你在不修改原始函数代码的情况下，动态地为函数添加新的功能。
    装饰器本质上是一个高阶函数，它接受一个函数作为参数，并返回一个新的函数或可调用对象。
    你可以使用 @decorator 语法糖来简化装饰器的使用。
    装饰器可以接受参数，也可以应用于带有参数的函数。
    类装饰器可以用来装饰类，通常用于修改类的行为或添加类级别的功能。
    多层装饰器会从最内层开始向外层依次应用。
    使用 functools.wraps 可以保留原始函数的元信息。
    Python 提供了一些内置的装饰器，如 @staticmethod、@classmethod、@property 和 @functools.lru_cache。